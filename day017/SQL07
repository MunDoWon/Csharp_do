SELECT * FROM DEPT;
SELECT * FROM EMP;
SELECT * FROM EMP,DEPT;

SELECT EMPNO,ENAME,E.DEPTNO,LOC FROM EMP E,DEPT D
WHERE E.DEPTNO=D.DEPTNO;

#급여범위를 지정하는 조건식으로 조인
SELECT * FROM SALGRADE;
SELECT * FROM EMP;
#비등가 JOIN
SELECT * FROM EMP E, SALGRADE S
WHERE E.SAL BETWEEN S.LOSAL AND S.HISAL;

#자체 JOIN
SELECT * FROM EMP E, EMP C
WHERE E.MGR = C.EMPNO;

SELECT E1.EMPNO ,E1.ENAME,E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1,EMP E2
WHERE E1.MGR=E2.MGR;
    
#외부조인 OUTTER JOIN
SELECT * FROM EMP;
SELECT COUNT(*) FROM EMP;
SELECT * FROM EMP WHERE ENAME ='KING';

#LEFT OUTTER JOIN
SELECT E1.EMPNO ,E1.ENAME,E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1,EMP E2
WHERE E1.MGR=E2.EMPNO(+);

#RIGHT OUTTER JOIN
SELECT E1.EMPNO ,E1.ENAME,E1.MGR,
       E2.EMPNO AS MGR_EMPNO,
       E2.ENAME AS MGR_ENAME
FROM EMP E1,EMP E2
WHERE E1.MGR(+)=E2.EMPNO;

#ANSI 표준
#SQL-99
SELECT E.EMPNO, E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,D.DEPTNO,
    D.DNAME,D.LOC
FROM EMP E NATURAL JOIN DEPT D
ORDER BY DEPTNO,E.EMPNO;

#234 JOIN~ON
SELECT E.EMPNO, E.ENAME,E.JOB,E.MGR,E.HIREDATE,E.SAL,E.COMM,D.DEPTNO,
    D.DNAME,D.LOC
FROM EMP E JOIN DEPT D ON(E.DEPTNO=D,DEPTNO)
ORDER BY DEPTNO,E.EMPNO;
#8-14 LEFT OUTTER JOIN
SELECT E1.EMPNO, E1.ENAME,E1.MGR,
        E2.EMPNO AS MGR_EMPNO,
        E2.ENAME AS MGR_ENAME
FROM EMP E1 LEFT JOIN EMP E2 ON(E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;
#8-15 RIGHT OUTER JOIN으로 위 쿼리를 작성해주세요
SELECT E1.EMPNO, E1.ENAME,E1.MGR,
        E2.EMPNO AS MGR_EMPNO,
        E2.ENAME AS MGR_ENAME
FROM EMP E1 RIGHT JOIN EMP E2 ON(E1.MGR=E2.EMPNO)
ORDER BY E1.EMPNO;

#239-3모든부서정보와 사원정보,부서번호 사원이름순정렬
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.JOB,E.SAL
FROM EMP E JOIN DEPT D ON (E.DEPTNO=D.DEPTNO)
ORDER BY DEPTNO,DNAME,ENAME;

#239-4 모든 부서,사원,급여등급정보,사원의 직속상관정보를 부서번호,사원번호순정렬SALGRADE
SELECT D.DEPTNO,D.DNAME,E.EMPNO,E.ENAME,E.MGR,E.SAL,E.DEPTNO,S.LOSAL,
        S.HISAL,S.GRADE,E1.EMPNO AS MGR_EMPNO,E1.ENAME AS MGR_ENAME;
        
#SUB QUERY
#사원 이름이 'JONES'인 사원 급여 출력
SELECT SAL FROM EMP WHERE ENAME='JONES';
#급여가 2975보다 높은 사원정보 출력
SELECT * FROM EMP WHERE SAL >2975;
#급여가 존스보다 높은 사원정보 출력
SELECT ENAME,SAL FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'JONES');
#KING보다 급여가 많은사람
SELECT ENAME,SAL FROM EMP
WHERE SAL > (SELECT SAL FROM EMP WHERE ENAME = 'KING');

#EMP 테이블의 사원정보중 ALLEN의 COMM보다 많이 받는 사원은?
SELECT * FROM EMP 
WHERE COMM >(SELECT COMM FROM EMP WHERE ENAME = 'ALLEN');

#9-4서브쿼리의 결과값이 날짜형인 경우
#ALLEN 보다 입사일이 빠른직원은?
SELECT * FROM EMP 
WHERE HIREDATE < (SELECT HIREDATE FROM EMP WHERE ENAME = 'ALLEN');

#9-5 JOIN 구문에서 SQ가 동작할까?
#평균급여보다 많이 받는 직원들의 정보는??
SELECT E.EMPNO,E.ENAME,E.JOB,E.SAL,
        D.DEPTNO,D.DNAME,D.LOC
FROM EMP E,DEPT D WHERE D.DEPTNO = E.DEPTNO 
AND E.SAL > (SELECT AVG(SAL) FROM EMP); 

#다중행 연산자 249
# IN 메인쿼리의 '데이터'가 서브쿼리의 결과 중 하나라도 일치하는 데이터 있으면 TRUE
# ANY,SOME 메인쿼리의 '조건식'을 만족하는 섭쿼리의 결과가 하나 이상이면 TRUE
# ALL 메인쿼리 조건식을 서브쿼리의' 결과 모두'가 만족하면 TRUE
# EXISTS 서브쿼리 결과가 존재시 (행이1개이상) TRUE
#실행결과가 여러개인 쿼리를 확인

# IN 연산자 하나라도 일치
SELECT * FROM EMP
WHERE DEPTNO IN (20,30);
#각 부서별 최고급여와 동일한 급여를 받는 사원정보 출력
SELECT * FROM EMP WHERE SAL IN
(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

# ANY 하나이상
SELECT * FROM EMP WHERE SAL = ANY
(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

# SOME 하나이상
SELECT * FROM EMP WHERE SAL = SOME
(SELECT MAX(SAL) FROM EMP GROUP BY DEPTNO)
ORDER BY DEPTNO;

# ANY 30번 부서 사원들의 최대 급여보다 적은 급여를 받는 사원정보출력
SELECT SAL FROM EMP WHERE DEPTNO =30;
SELECT * FROM EMP WHERE SAL < ANY( SELECT SAL FROM EMP WHERE DEPTNO =30);

#9-14 ALL
#30번부서 사원의 최소급여보다 더 적은 급여를 받는 직원
SELECT SAL FROM EMP WHERE DEPTNO=30;
SELECT *FROM EMP WHERE SAL < ALL(SELECT SAL FROM EMP WHERE DEPTNO =30);

SELECT * FROM EMP WHERE (DEPTNO, SAL) IN 
(SELECT DEPTNO, MAX(SAL) FROM EMP GROUP BY DEPTNO);

#연습문제 266-1
SELECT E.JOB,E.EMPNO,E.ENAME,E.SAL,E.DEPTNO,D.DNAME 
FROM EMP E,DEPT D 
WHERE E.DEPTNO=D.DEPTNO AND JOB = (SELECT JOB FROM EMP 
    WHERE ENAME='ALLEN');
    
#266-2
SELECT E.EMPNO,E.ENAME,D.DNAME,E.HIREDATE,D.LOC,E.SAL,S.GRADE 
FROM EMP E ,DEPT D, SALGRADE S
WHERE E.DEPTNO = D.DEPTNO AND E.SAL > (SELECT AVG(SAL) FROM EMP) 
    AND E.SAL BETWEEN S.LOSAL AND S. HISAL
ORDER BY SAL DESC, EMPNO ASC;
#SQL-99
SELECT E.EMPNO,E.ENAME,D.DNAME,E.HIREDATE,D.LOC,E.SAL,S.GRADE 
FROM EMP E JOIN DEPT D ON(E.DEPTNO = D.DEPTNO)
JOIN SALGRADE S ON(E.SAL BETWEEN S.LOSAL AND S. HISAL)
WHERE E.SAL > (SELECT AVG(SAL) FROM EMP)
ORDER BY SAL DESC, EMPNO DESC;

#DEPT테이블이 있다 복사해보자 -->DEPT_TEMP
CREATE TABLE DEPT_TEMP AS SELECT * FROM DEPT;
SELECT * FROM DEPT_TEMP;
#데이터 추가
#50번 부서 'DATABASE','SEOUL'
INSERT INTO DEPT_TEMP(DEPTNO,DNAME,LOC)
VALUES(50,'DATABASE','SEOUL');

INSERT INTO DEPT_TEMP(DEPTNO,DNAME,LOC)
VALUES(60,'NETWORK','BUSAN''ASD' );
#
INSERT INTO DEPT_TEMP(DEPTNO,DNAME,LOC)
VALUES(70,'NETWORK2','ANDONG');
#NULL가능? ㅆ가능
INSERT INTO DEPT_TEMP(DEPTNO,LOC)
VALUES(90,'INCHEON');
INSERT INTO DEPT_TEMP(DEPTNO,DNAME,LOC)
VALUES(80,'MOBILE','');

#날짜 데이터 입력
CREATE TABLE EMP_TEMP AS SELECT * FROM EMP WHERE 1<>1;
SELECT *FROM EMP_TEMP;
INSERT INTO EMP_TEMP
VALUES(1111,'성춘향','PRESIDENT',NULL,
        TO_DATE('07/01/2001','DD/MM/YYYY'),5000,1000,10);
INSERT INTO EMP_TEMP
VALUES(2222,'성춘향','PRESIDENT',NULL,
        SYSDATE,5000,1000,10);
        
# UPDATE
CREATE TABLE DEPT_TEMP2 AS SELECT * FROM DEPT;
COMMIT;
UPDATE DEPT_TEMP2 SET LOC ='SEOUL';
ROLLBACK;
UPDATE DEPT_TEMP2 SET LOC ='SEOUL'
WHERE DEPTNO=40;
SELECT * FROM DEPT_TEMP2;

# DELETE
SELECT * FROM DEPT_TEMP2;
DELETE FROM DEPT_TEMP2 WHERE DEPTNO =40;
DELETE FROM DEPT_TEMP2 WHERE LOC ='DALLAS';
ROLLBACK;
